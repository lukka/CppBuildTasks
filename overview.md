This extension provides the tasks **'run-vcpkg'** and **'run-cmake'** to build C++ code on Azure DevOps pipelines. Full examples and real world projects are provided in the [README.md](https://github.com/lukka/CppBuildTasks/blob/master/README.md) file.

## The ***run-vcpkg*** task

The task completes the following steps:

  1. checks whether vcpkg is already located at the path specified by `vcpkgDirectory` (e.g. vcpkg could be a submodule of the Git repository checked out along with the parent repository);
  1. if vcpkg is not there, it uses [Git](https://git-scm.com/) to fetch [vcpkg](https://github.com/microsoft/vcpkg) into that directory;
  1. if needed vcpkg is built;
  1. eventually vcpkg is launched to build and install the specified ports.

The task sets `VCPKG_ROOT` task variable, which is automatically used by subsequent **'run-cmake'** to consume the vcpkg's toolchain file.

### Use **vcpkg** as a submodule of your Git repository ###

When using this **vcpkg**, be aware of how it works, specifically:
 - a specific version of vcpkg must be used either locally and on build servers;
 - a specific version of vcpkg is identified by the commit id or tag (e.g. release tag `2019.07`) of the used vcpkg repository;
 - it not possible to choose which version of the port to install, instead it is the used version of vcpkg that establishes which version of the port is available;
 
 To sum up, to keep a consistent development experience between local and remote build environments, **it is highly suggested to use vcpkg as submodule of your Git repository**; this way the version of vcpkg used is implied by the commit id specified by the submodule for vcpkg.

### Use vcpkg's response file as parameter

vcpkg accepts a response file that contains its arguments. It is useful to store under source control a text file containing the list of ports to be installed. This helps to run the vcpkg the same exact way locally and on the build servers. For example if you want to run:

 > vcpkg install boost zlib:x64 libmodbus --triplet x64

it is instead possible to run

 > vcpkg install @response_file.txt

 where `response_file.txt` contains (with no trailing whitespaces allowed):

```yaml
   boost
   zlib:x64
   libmodbus
   --triplet
   x64
```

### Caching vcpkg's artifacts

To minimize build time, the [Cache task](https://docs.microsoft.com/en-us/azure/devops/pipelines/caching/?view=azure-devops) should be used to cache the entire vcpkg's directory (which is specified by `vcpkgDirectory` of **'run-vcpkg'** task).

_Note:_ since only the `installed` subdirectory and the `vcpkg` executable file should be cached, everything but those are excluded by the `.artifactignore` file generated by the *vcpkg-run* task.

The `key` provided to the [Cache task](https://docs.microsoft.com/en-us/azure/devops/pipelines/caching/?view=azure-devops) must uniquely identify the following:
  - the vcpkg version, which identifies also all the provided ports and their specific version;
  - the used triplet and the list of ports to be built and installed;
  - the platform and the toolset used when building ports;

The following sample [key](https://docs.microsoft.com/en-us/azure/devops/pipelines/caching/?view=azure-devops#task-configuration) should grant most of the above:

```yaml
key:  $(vcpkgCommitId)| @$(Build.SourcesDirectory)/response_file_with_ports_and_triplet.txt | "$(Agent.OS)"
```
where:
  - the `$(vcpkgCommitId)` identifies a specific version of vcpkg by means of a Git commit id or tag. It is suggested to use vcpkg as a submodule of your repository, at the root for example, in such case the commit id is stored in file `$(Build.SourcesDirectory)/.git/modules/vcpkg/HEAD`. Note that a branch name should not be used, as it does not  identify uniquely the version of vcpkg;
  - the response file contains the list of ports along with the triplet, e.g. 

    ```sqlite3 --triplet x64-linux```

    or another identical example 
  
    `sqlite3:x64-windows`. The `--triplet` argument specifies the default value when a port has not the triplet specified.
  
  - `$(Agent.OS)` captures only the build agent platform. If needed, it might be useful to add further values in the key to uniquely identifies the toolset used when building.

_Note:_ the key must be a one liner, it could be divided in segments with the pipe character, each non-file-path segment must be enclosed with double quotes. [As documented](https://docs.microsoft.com/en-us/azure/devops/pipelines/caching/?view=azure-devops#key-input), for file-path segments a hash value is computed, while the non-file-path segment values are used as is.


## The ***run-cmake*** task

The **'run-cmake'** task works with CMakeLists.txt and [CMakeSettings.json](https://docs.microsoft.com/en-us/cpp/build/cmakesettings-reference?view=vs-2019).
It can leverage the previous execution of the **'run-vcpkg'** task by using the `VCPKG_ROOT`  task variable to:

  - set the vcpkg's toolchain file if requested, located at `$VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake`;
  - set the environment for the provided triplet when building with [msvc](https://docs.microsoft.com/en-us/cpp/build/reference/c-cpp-building-reference?view=vs-2019) on Windows (i.e. building in the environment created by launching `$VCPKG_ROOT/vcpkg env`); 
 
## Questions and Answers

### Why not one single task?

Because you could use vcpkg without CMake. Or you could use CMake without vcpkg.

### Would creating an ad-hoc bash/powershell script be easier?

Absolutely! Anyone can use this task as an inspiration for writing their own scripts to suite specific needs.
The purpose of the tasks is to streamline and to simplify the usage of vcpkg and CMake on build servers.

### Why the **'run-vcpkg'** task runs vcpkg in any case, even when cached port files are restored?

Indeed it is not needed to run vcpkg when the cache is being restored, and you could use [Cache task](https://docs.microsoft.com/en-us/azure/devops/pipelines/caching/?view=azure-devops)'s  `cacheHitVar` parameter to control the execution of the **'run-vcpkg'** task. Currently **'run-vcpkg'** task defensively runs vcpkg as a sanity check: it should output in the build log that all the requested ports are installed already, spending a neglibile amount of time.

## Please get the source and contribute

The software is provided as is, there is no warranty of any kind. All users are encouraged to get the [source code](https://github.com/lukka/CppBuildTasks) and improve the tasks with fixes and new features. 

## Tasks' Flowcharts

### The 'Run CMake" flowchart

The flowchart has two entry points as it could be used with a CMakeLists.txt or with a CMakeSettings.json file.


>  ![Run CMake task](task-cmake/docs/task-cmake.png)


### The 'Run vcpkg' flowchart


>  ![Run vcpkg task](task-vcpkg/docs/task-vcpkg.png)


